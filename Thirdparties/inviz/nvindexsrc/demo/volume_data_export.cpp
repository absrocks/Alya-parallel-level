/******************************************************************************
 * Copyright 1986, 2017 NVIDIA Corporation. All rights reserved.
 *****************************************************************************/
/// \file

#include "volume_data_export.h"

#include <nv/index/iregular_volume.h>
#include <nv/index/isession.h>
#include <nv/index/iscene.h>

#include "common/forwarding_logger.h"
#include "common/type_conversion_utility.h"

#include "nvindex_appdata.h"
#include "scene_utility.h"
#include "utilities.h"
#include "volume_data_retrieval_appjob.h"

#include <cassert>

//----------------------------------------------------------------------
/// get bounding box range. bounding box [min, max]
/// \param[in] maxval bounding box max
/// \param[in] minval bounding box min
/// \return size of the box
inline mi::Sint32 get_bound_size(mi::Sint32 maxval, mi::Sint32 minval)
{
    assert(minval <= maxval);
    mi::Sint32 size = (maxval - minval);

    return size;
}

//----------------------------------------------------------------------
Volume_data_exporter::Volume_data_exporter(
    const mi::neuraylib::Tag&                                            volume_tag,
    const mi::math::Bbox<mi::Sint32, 3>&                                 ijk_bbox,
    mi::base::Handle<const nv::index::IData_distribution>&               data_distribution,
    mi::base::Handle<const nv::index::IDistributed_data_access_factory>& data_access_factory)
    : 
    m_volume_tag(volume_tag),
    m_ijk_bbox(ijk_bbox),
    m_data_distribution(data_distribution),
    m_data_access_factory(data_access_factory)
{
    // empty
}

//----------------------------------------------------------------------
bool Volume_data_exporter::export_to_local_file(
    const std::string & fpath,
    mi::neuraylib::IDice_transaction * dice_transaction
    ) const
{
    INFO_LOG << "ijk bounding box [min,max] = " << m_ijk_bbox;

    mi::math::Bbox<mi::Sint32, 3> bbox(m_ijk_bbox);
    if(bbox.empty() || (!bbox.volume())){
        ERROR_LOG << "illegal ijk_bbox: " << m_ijk_bbox << ", no volume.";
        return false;
    }

    // slices_transfer_once_count = -1 means transfer whole octree
    // leaf.  When this is positive value, transfer
    // slices_transfer_once_count slices.
    const mi::Sint32 slices_transfer_once_count = -1;

    const bool ret = export_to_local_file_with_n_slices(fpath,
                                                        slices_transfer_once_count,
                                                        dice_transaction);

    return ret;
}

//----------------------------------------------------------------------
bool Volume_data_exporter::is_valid_export_region(
    const mi::math::Bbox<mi::Sint32, 3> & volume_bbox,
    const std::vector< mi::math::Bbox<mi::Sint32, 3> > & export_all_bbox_vec)
    const
{
    const mi::Size nb_query_all_bbox = export_all_bbox_vec.size();

    // check the exporting volume exists
    if ((!volume_bbox.contains(m_ijk_bbox.min)) ||
        (!volume_bbox.contains(m_ijk_bbox.max)))
    {
        // error message will be generated by the caller
        return false;
    }

    for (mi::Size i = 0; i < nb_query_all_bbox; ++i)
    {
        if ((!volume_bbox.contains(export_all_bbox_vec[i].min)) ||
            (!volume_bbox.contains(export_all_bbox_vec[i].max)))
        {
            // error message will be generated by the caller
            return false;
        }
    }
    return true;
}

//----------------------------------------------------------------------
bool Volume_data_exporter::export_to_local_file_with_n_slices(
    const std::string & fpath,
    mi::Sint32 slices_transfer_once_count,
    mi::neuraylib::IDice_transaction * dice_transaction) const
{
    assert(!fpath.empty());
    assert(dice_transaction != 0);

    // get volume size
    mi::math::Vector<mi::Uint32, 3> volume_size = get_volume_size(m_volume_tag, dice_transaction);
    mi::math::Bbox<mi::Sint32, 3>   whole_volume_bbox(
        nv::index_common::convert_bbox_type<mi::Sint32, mi::Uint32, 3>(
            mi::math::Bbox<mi::Uint32, 3>(mi::math::Vector<mi::Uint32, 3>(0, 0, 0),
                                          volume_size)));
    if(!(whole_volume_bbox.contains(m_ijk_bbox.min) && whole_volume_bbox.contains(m_ijk_bbox.max))){
        ERROR_LOG << "invalid exporting volume region: " << m_ijk_bbox << " should be in "
                  << whole_volume_bbox;
        return false;
    }

    FILE * p_export_fp = fopen(fpath.c_str(), "w+");
    if(p_export_fp == 0){
        ERROR_LOG << "Failed to open exporting file [" << fpath << "]. no export.";
        return false;
    }
    INFO_LOG << "exporting volume file = [" << fpath << "]";


    // get exporting bounding boxes
    std::vector< mi::math::Bbox<mi::Sint32, 3> > export_all_bbox_vec;
    this->get_exporting_bbox(dice_transaction, export_all_bbox_vec);


    const mi::Size nb_query_all_bbox = export_all_bbox_vec.size();

    // check the exporting volume exists
    if((!this->is_valid_export_region(whole_volume_bbox, export_all_bbox_vec))){
        ERROR_LOG << "Specified export region is outside of the data. Is it global ROI?";
        ERROR_LOG << "whole_volume_bbox:     " << whole_volume_bbox;
        ERROR_LOG << "region of interest bbox: " << m_ijk_bbox;
        ERROR_LOG << "No data export.";
        fclose(p_export_fp);
        return false;
    }

    bool is_ok = true;
    if(nb_query_all_bbox == 0){
        // no bounding box found.
        INFO_LOG << "no exportable volume bounding box found.";
    }
    else{
        // access the data partially
        for(mi::Size i = 0; i < nb_query_all_bbox; ++i){
            std::vector< mi::math::Bbox<mi::Sint32, 3> > bbox_partial_vec;
            bbox_partial_vec.push_back(export_all_bbox_vec[i]);
            if(!this->export_partial_volume(p_export_fp,
                                            whole_volume_bbox,
                                            bbox_partial_vec,
                                            slices_transfer_once_count,
                                            dice_transaction)){
                ERROR_LOG << "Failed to write one bbox to the file [" << fpath << "]";
                is_ok = false;
                break;
            }
        }
    }

    const mi::Sint32 ret_fclose = fclose(p_export_fp);
    if(ret_fclose != 0){
        // fclose failed
        ERROR_LOG << "Can not close the file [" << fpath << "]";
        is_ok = false;
    }

    return is_ok;
}


//----------------------------------------------------------------------
bool Volume_data_exporter::export_partial_volume(
    FILE * p_export_fp,
    const mi::math::Bbox<mi::Sint32, 3> & whole_volume_bbox,
    const std::vector< mi::math::Bbox<mi::Sint32, 3> > & bbox_partial_vec,
    mi::Sint32 number_of_slices_transfer,
    mi::neuraylib::IDice_transaction * dice_transaction) const
{
    assert(p_export_fp != 0);
    assert(!bbox_partial_vec.empty());

    const mi::Size nb_bbox = bbox_partial_vec.size();
    for(mi::Size i = 0; i < nb_bbox; ++i){

        mi::math::Bbox<mi::Sint32, 3> sub_bbox = bbox_partial_vec[i];
        assert(sub_bbox.rank() == 3);

        const mi::math::Vector<mi::Sint32, 2> total_k_range(sub_bbox.min.z, sub_bbox.max.z);
        // get n-slices from a patial volume
        if(number_of_slices_transfer == -1){
            // if == -1, then transfer all slices at once
            number_of_slices_transfer = sub_bbox.max.z - sub_bbox.min.z;
        }
        assert(number_of_slices_transfer > 0);

        // each bounding box has n slices
        std::vector< mi::math::Vector<mi::Sint32, 2> > slice_region_vec;
        get_region_vector(total_k_range, number_of_slices_transfer, slice_region_vec);
        assert(!slice_region_vec.empty()); // something should be transferred.

        // create transfer bounding boxes
        std::vector< mi::math::Bbox<mi::Sint32, 3> > transfer_bbox_vec;
        const mi::Size n_slice_count = slice_region_vec.size();
        for(mi::Size i = 0; i < n_slice_count; ++i){
            mi::math::Bbox<mi::Sint32, 3> transfer_bbox;
            transfer_bbox  = sub_bbox;
            sub_bbox.min.z = slice_region_vec[i].x;
            sub_bbox.max.z = slice_region_vec[i].y;
            transfer_bbox_vec.push_back(transfer_bbox);
        }

        const bool is_success = this->export_slices(dice_transaction,
                                                    p_export_fp,
                                                    whole_volume_bbox,
                                                    transfer_bbox_vec);
        if(!is_success){
            return false;
        }
    }

    // ---------------------------------------
    // The following code is no slice transfer
    // ---------------------------------------
    //  volume_data_retrieval_appjob
    //      data_retrieval_job(m_volume_tag, bbox_partial_vec, m_data_access_factory);
    //  const mi::Size nb_bbox = bbox_partial_vec.size();
    //  dice_transaction->execute_fragmented(&data_retrieval_job, nb_bbox);

    //  for(mi::Size i = 0; i < nb_bbox; ++i){
    //      mi::base::Handle<nv::index::IRegular_volume_data_access> seismic_data_access
    //          (data_retrieval_job.get_seismic_data(i));

    //      INFO_LOG << "Received seismic data [" << i << "], in bounds: "
    //               << seismic_data_access->get_bounds();
    //      const bool ret =
    //          this->write_one_bbox_to_file(p_export_fp,
    //                                       bbox_partial_vec[i],
    //                                       whole_volume_bbox,
    //                                       seismic_data_access->get_amplitude_values());
    //      if(!ret){
    //          return false;
    //      }
    //  }

    return true;
}

//----------------------------------------------------------------------
bool Volume_data_exporter::export_slices(
    mi::neuraylib::IDice_transaction * dice_transaction,
    FILE * p_export_fp,
    const mi::math::Bbox<mi::Sint32, 3> & whole_volume_bbox,
    const std::vector< mi::math::Bbox<mi::Sint32, 3> > & slice_bbox_vec) const
{
    assert(p_export_fp != 0);
    assert(!slice_bbox_vec.empty());

    // this volume_data_retrieval_appjob runs only local,
    // but, created other fragment job. See
    // Volume_data_retrieval_appjob::execute_fragment.
    Volume_data_retrieval_appjob
        data_retrieval_job(m_volume_tag, slice_bbox_vec, m_data_access_factory);
    const mi::Uint32 nb_bbox = slice_bbox_vec.size();
    dice_transaction->execute_fragmented(&data_retrieval_job, nb_bbox);

    for(mi::Uint32 i = 0; i < nb_bbox; ++i){
        mi::base::Handle<nv::index::IRegular_volume_data_access> volume_data_access
            (data_retrieval_job.get_seismic_data(i));

        const mi::base::Handle<const nv::index::IRegular_volume_data> volume_data(
            volume_data_access->get_volume_data());
        const mi::base::Handle<const nv::index::IRegular_volume_data_uint8> volume_data_uint8(
            volume_data->get_interface<const nv::index::IRegular_volume_data_uint8>());

        if (!volume_data_uint8) {
            ERROR_LOG << "Volume-data access failed: data access on non-uint8 volume type.";
            return false;
        }

        INFO_LOG << "Received volume data [" << i << "/" << nb_bbox << "], in bounds: "
                 << volume_data_access->get_bounding_box();
        const bool ret =
            this->write_one_bbox_to_file(p_export_fp,
                                         slice_bbox_vec[i],
                                         whole_volume_bbox,
                                         volume_data_uint8->get_voxel_data());
        if(!ret){
            return false;
        }
    }

    return true;
}


//----------------------------------------------------------------------
void Volume_data_exporter::get_exporting_bbox(
    mi::neuraylib::IDice_transaction* dice_transaction,
    std::vector< mi::math::Bbox<mi::Sint32, 3> > & export_bbox_vec) const
{
    export_bbox_vec.clear();

    mi::base::Handle<nv::index::IRegular_volume_data_locality> data_locality(
        m_data_distribution->retrieve_data_locality(
            m_volume_tag,
            nv::index_common::convert_bbox_type<mi::Uint32, mi::Sint32, 3>(m_ijk_bbox),
            dice_transaction));

    const mi::math::Bbox<mi::Sint32, 3> ijk_bbox = m_ijk_bbox;
    const mi::Uint32 nb_cluster_nodes = data_locality->get_nb_cluster_nodes();
    for (mi::Uint32 i = 0; i < nb_cluster_nodes; ++i)
    {
        const mi::Uint32 cluster_node_id = data_locality->get_cluster_node(i);
        // INFO_LOG << "cluster node id [" << i << "] = " << cluster_node_id;

        if (cluster_node_id == 0)
        {
            ERROR_LOG << "Cluster node id should not be 0.";
            continue;
        }

        const mi::Uint32 nb_bbox = static_cast<mi::Uint32>(data_locality->get_nb_bounding_box(cluster_node_id));

        for(mi::Uint32 box_id=0; box_id<nb_bbox; ++box_id)
        {
            // EXAMPLE: simply pick the ones the you feel make sense for a clever export of volume
            // 'Clever' should take into account:
            //  - the main memory restriction
            //  - the K-first and I-last export scheme
            //  - the number of data access calls (possibly)

            // The following is *not* very clever ;) - especially for large dataset sizes .....
            const mi::math::Bbox<mi::Sint32, 3> bbox(data_locality->get_bounding_box(cluster_node_id, box_id));
            if (bbox.intersects(ijk_bbox))
            {
                export_bbox_vec.push_back(bbox);
                INFO_LOG << "get_exporting_bbox: bounding box = " << bbox;
            }
        }
    }
}

//----------------------------------------------------------------------
bool Volume_data_exporter::write_one_bbox_to_file(
    FILE * p_outfile,
    const mi::math::Bbox<mi::Sint32, 3> & subvol_bbox,
    const mi::math::Bbox<mi::Sint32, 3> & whole_volume_bbox,
    const nv::index_common::VoxelType*    p_data) const
{
    assert(p_outfile != 0);
    assert(p_data != 0);

    INFO_LOG << "writing: bbox = " << subvol_bbox;

    const mi::math::Vector<mi::Sint32, 3> bbmin = subvol_bbox.min;
    const mi::math::Vector<mi::Sint32, 3> bbmax = subvol_bbox.max;

    bool is_ok = true;
    for(mi::Sint32 i = bbmin.x; i < bbmax.x; ++i){
        for(mi::Sint32 j = bbmin.y; j < bbmax.y; ++j){
            const mi::Sint32 kmin = bbmin.z;
            const mi::Sint32 kmax = bbmax.z;
            assert(kmin <= kmax);
            const mi::Sint32 k_span_size = get_bound_size(kmax, kmin); // bbox ... [min,max)
            const mi::Sint64 memidx =
                this->subvol_bbox_ijk_to_memory_index(i, j, kmin, subvol_bbox);
            const nv::index_common::VoxelType * p_k_line_top = p_data + memidx;

            const mi::Sint64 fpos =
                this->ROI_bbox_ijk_to_file_position_index(i, j, kmin,
                                                          m_ijk_bbox,
                                                          whole_volume_bbox);

            //             INFO_LOG << "writing [" << i << " " << j << " " << kmin
            //                      << "], mem [" << memidx << "], " << k_span_size << " at "
            //                      << fpos << ", x= p_k_line_top = " << (void *)p_k_line_top;
            //             // DEBUG
            //             {
            //                 for(mi::Sint32 kk = kmin; kk <= kmax; ++kk){
            //                     std::cout << static_cast< mi::Sint32 >(p_k_line_top[kk]) << " ";
            //                 }
            //                 std::cout << std::endl;
            //             }
            //             // END DEBUG

            assert(fpos >= 0L);
            // bbox max is the size by origin 0.
            assert(fpos <= (static_cast< mi::Sint64 >(whole_volume_bbox.max.x) *
                            static_cast< mi::Sint64 >(whole_volume_bbox.max.y) *
                            static_cast< mi::Sint64 >(whole_volume_bbox.max.z)));

            const mi::Sint64 ret_fseek  = fseek(p_outfile, fpos, SEEK_SET);
            if(ret_fseek != 0){
                is_ok = false;
                ERROR_LOG << "fseek failed";
                break;
            }

            // assuming k (height/time) is continuous in the memory.
            const mi::Size ret_fwrite =
                fwrite(p_k_line_top, sizeof(nv::index_common::VoxelType), k_span_size, p_outfile);
            if(ret_fwrite != static_cast< size_t >(k_span_size)){
                is_ok = false;
                ERROR_LOG << "Write failed";
                break;
            }
            // INFO_LOG << "(i j) = (" << i << " " << j << ")";
        }
        // std::cout << i << " ";
    }
    // std::cout << std::endl;
    INFO_LOG << "write done.";

    return is_ok;
}

//----------------------------------------------------------------------
mi::Sint64 Volume_data_exporter::subvol_bbox_ijk_to_memory_index(
    mi::Sint32 i,
    mi::Sint32 j,
    mi::Sint32 k,
    const mi::math::Bbox<mi::Sint32, 3> & subvol_bbox) const
{
    assert((subvol_bbox.min.x <= i) && (i < subvol_bbox.max.x));
    assert((subvol_bbox.min.y <= j) && (j < subvol_bbox.max.y));
    assert((subvol_bbox.min.z <= k) && (k < subvol_bbox.max.z));

    const mi::Sint64 delta_j = get_bound_size(subvol_bbox.max.y, subvol_bbox.min.y);
    const mi::Sint64 delta_k = get_bound_size(subvol_bbox.max.z, subvol_bbox.min.z);
    assert(delta_j > 0L);
    assert(delta_k > 0L);

    // shift the offset
    const mi::Sint64 source_i = i - subvol_bbox.min.x;
    const mi::Sint64 source_j = j - subvol_bbox.min.y;
    const mi::Sint64 source_k = k - subvol_bbox.min.z;

    const mi::Sint64 idx = source_k + delta_k * (source_j + (delta_j * source_i));
    assert(idx >= 0L);

    return idx;
}

//----------------------------------------------------------------------
mi::Sint64 Volume_data_exporter::ROI_bbox_ijk_to_file_position_index(
    mi::Sint32 i,
    mi::Sint32 j,
    mi::Sint32 k,
    const mi::math::Bbox<mi::Sint32, 3> & roi_bbox,
    const mi::math::Bbox<mi::Sint32, 3> & subvol_bbox) const
{
    assert((roi_bbox.min.x <= i) && (i < roi_bbox.max.x));
    assert((roi_bbox.min.y <= j) && (j < roi_bbox.max.y));
    assert((roi_bbox.min.z <= k) && (k < roi_bbox.max.z));

    assert((subvol_bbox.min.x <= roi_bbox.min.x) &&
           (roi_bbox.max.x    <= subvol_bbox.max.x));
    assert((subvol_bbox.min.y <= roi_bbox.min.y) &&
           (roi_bbox.max.y    <= subvol_bbox.max.y));
    assert((subvol_bbox.min.z <= roi_bbox.min.z) &&
           (roi_bbox.max.z    <= subvol_bbox.max.z));

    // get the index
    const mi::Sint64 delta_roi_j    = get_bound_size(roi_bbox.max.y,    roi_bbox.min.y);
    const mi::Sint64 delta_roi_k    = get_bound_size(roi_bbox.max.z,    roi_bbox.min.z);
    const mi::Sint64 delta_volume_j = get_bound_size(subvol_bbox.max.y, subvol_bbox.min.y);
    const mi::Sint64 delta_volume_k = get_bound_size(subvol_bbox.max.z, subvol_bbox.min.z);
    assert(delta_roi_j > 0L);
    assert(delta_roi_k > 0L);
    assert(delta_volume_j > 0L);
    assert(delta_volume_k > 0L);

    //     INFO_LOG << "delta_roi_k,j [" << delta_roi_k << ", " << delta_roi_j
    //              << "], delta_volume_k,j [" << delta_volume_k << ", "
    //              << delta_volume_j << "]";

    const mi::Uint32 source_i = i - roi_bbox.min.x;
    const mi::Uint32 source_j = j - roi_bbox.min.y;
    const mi::Uint32 source_k = k - roi_bbox.min.z;
    assert(i >= roi_bbox.min.x);
    assert(j >= roi_bbox.min.y);
    assert(k >= roi_bbox.min.z);

    const mi::Sint64 idx = source_k + delta_roi_k * (source_j + (delta_roi_j * source_i));

    if(idx < 0L){
        ERROR_LOG << "roi_bbox = " << roi_bbox << ", " << subvol_bbox << subvol_bbox;
        ERROR_LOG << "ijk = " << i << ", " << j << ", " << k
                  << ". delta_roi_k,j[" << delta_roi_k << ", " << delta_roi_j << "], delta_volume_k,j ["
                  << delta_volume_k << ", " << delta_volume_j << "], idx = " << idx;
    }
    assert(idx >= 0L);

    return idx;
}

//----------------------------------------------------------------------
bool export_volume_data(
    const mi::neuraylib::Tag &            volume_tag,
    const mi::math::Bbox<mi::Sint32, 3> & ijk_bbox,
    const std::string&                    export_fname,
    const mi::neuraylib::Tag&             session_tag,
    mi::neuraylib::IDice_transaction *    dice_transaction)
{
    assert(dice_transaction != 0);
    assert(volume_tag.is_valid());
    assert(session_tag.is_valid());
    assert(!export_fname.empty());

    mi::base::Handle<const nv::index::ISession> session(
        dice_transaction->access<const nv::index::ISession>(session_tag));
    assert(session.is_valid_interface());

    mi::base::Handle<const nv::index::IData_distribution> subsurface_data_distribution(
        dice_transaction->access<const nv::index::IData_distribution>(
            session->get_distribution_layout()));
    assert(subsurface_data_distribution.is_valid_interface());

    mi::base::Handle<const nv::index::IDistributed_data_access_factory>
        subsurface_data_access_factory(
            dice_transaction->access<const nv::index::IDistributed_data_access_factory>(
                session->get_data_access_factory()));
    assert(subsurface_data_access_factory.is_valid_interface());

    // check the ROI validity
    mi::math::Bbox<mi::Float32, 3> xyz_roi_float =
        get_XYZ_global_region_of_interest_bbox(session.get(), dice_transaction);
    mi::math::Bbox<mi::Float32, 3> ijk_bbox_float = 
        nv::index_common::convert_bbox_type<mi::Float32, mi::Sint32, 3>(ijk_bbox);
    if (!(xyz_roi_float.contains(ijk_bbox_float.min) && xyz_roi_float.contains(ijk_bbox_float.max)))
    {
        // ijk_bbox is not inside (or on) the xyz_roi
        ERROR_LOG << "The exporting volume ijk_bbox is outside of the global xyz ROI. "
                  << "This will give a corrupted result. global ROI:"
                  << xyz_roi_float << ", ijk_bbox: " << ijk_bbox_float;
        return false;
    }

    Volume_data_exporter exporter(
        volume_tag,
        ijk_bbox,
        subsurface_data_distribution,
        subsurface_data_access_factory);

    const bool ret = exporter.export_to_local_file(export_fname, dice_transaction);
    if(!ret){
        // no volume data export.
        return false;
    }

    return true;
}

//----------------------------------------------------------------------
