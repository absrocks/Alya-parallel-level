/******************************************************************************
 * Copyright 1986, 2017 NVIDIA Corporation. All rights reserved.
 *****************************************************************************/
/// \file
/// \brief Perlin noise utility

#ifndef NVIDIA_INDEX_BIN_COMMON_PERLIN_NOISE_UTILITY_H
#define NVIDIA_INDEX_BIN_COMMON_PERLIN_NOISE_UTILITY_H

#include <mi/dice.h>
#include <cmath>

namespace nv {
namespace index_common {
// helper functions
/// perlin noise fade
inline mi::Float32 fade(const mi::Float32 t) { return t * t * t * (t * (t * 6.0f - 15.0f) + 10.0f); }
/// floor and int
inline mi::Sint32 __float2int_rd(const mi::Float32 f) { return (mi::Sint32)floorf(f); }
/// linear interpolation
inline mi::Float32 lerp(const mi::Float32 a, const mi::Float32 b, const mi::Float32 t){ return (b-a)*t + a; }

static unsigned char const rnd1[256] = {151,160,137,91,90,15,
131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180};
static unsigned char const rnd2[256] = {120,73,105,71,106,25,159,92,184,93,179,181,
51,168,252,235,114,143,108,82,4,72,9,192,214,112,12,200,188,8,187,117,157,88,70,87,
56,38,115,96,59,24,215,231,123,44,144,119,243,245,212,249,197,109,76,66,183,58,232,
113,86,234,203,80,163,254,140,62,174,118,167,18,55,99,126,170,52,149,156,142,89,189,
178,240,255,251,169,226,236,153,223,219,54,130,133,7,173,77,242,190,1,122,27,147,196,
180,238,124,145,101,195,57,61,39,53,154,45,47,107,233,20,176,83,36,136,138,15,230,
246,94,69,6,135,132,29,131,172,199,228,177,182,216,134,151,95,17,218,155,19,175,41,
191,85,23,160,125,248,42,209,165,110,102,79,221,32,26,217,2,46,81,74,16,63,202,220,
37,75,205,13,21,68,148,40,253,241,250,141,164,35,104,49,50,224,166,247,208,162,193,
150,30,14,10,60,98,207,84,11,239,100,116,152,90,225,129,128,64,28,158,186,127,97,
204,206,65,5,194,91,67,198,48,111,211,227,229,237,244,43,146,139,222,137,201,22,103,
210,34,213,31,0,33,185,161,78,121,171,3};
static unsigned char const rnd3[256] = {
88,147,251,140,206,77,107,169,5,222,84,97,116,234,24,90,201,133,40,216,229,34,37,
158,186,49,98,61,47,9,124,123,65,249,2,66,76,172,198,179,218,210,78,170,132,32,60,
110,213,223,151,225,115,83,180,161,42,41,164,250,233,70,231,27,217,244,114,96,183,
228,63,195,236,192,177,209,246,109,171,72,101,23,35,112,182,162,57,69,146,81,248,215,
7,154,178,252,136,55,150,8,1,142,167,199,39,3,14,135,152,74,33,243,121,13,181,26,211,
19,64,168,58,67,52,143,113,43,25,240,166,59,4,187,53,238,103,159,220,204,208,245,85,
122,62,120,93,191,224,16,68,80,226,207,134,188,73,232,102,125,196,254,253,130,241,
46,119,38,94,221,153,100,163,175,242,131,255,214,87,139,92,12,203,117,219,21,239,6,
31,20,44,50,28,111,141,18,157,145,11,30,237,82,129,200,89,148,95,194,144,128,176,45,
79,106,235,75,0,230,160,126,138,227,247,91,17,173,29,51,71,22,36,118,149,189,155,156,
197,54,202,99,174,137,105,184,205,108,10,193,165,127,56,212,104,190,185,48,86,15};
static unsigned char const rnd4[256] = {
249,199,162,114,17,55,64,57,29,137,194,247,45,70,210,106,184,178,219,122,156,193,
214,126,138,28,148,121,19,37,135,132,173,225,221,161,180,220,36,84,224,10,185,209,
238,119,89,253,165,248,120,235,198,52,3,190,125,226,20,6,168,2,170,167,94,54,201,
179,42,208,242,33,146,158,245,196,166,83,86,34,74,188,44,49,85,11,243,4,99,100,102,
78,252,26,35,24,113,236,237,9,1,72,63,204,13,15,129,53,79,163,212,213,48,92,97,38,
189,68,230,234,41,22,246,133,250,202,77,112,18,218,229,124,181,14,108,107,255,91,
145,223,134,142,96,88,222,207,141,175,203,27,69,95,62,47,147,164,130,232,39,244,21,
154,239,153,110,172,59,46,81,176,217,80,150,159,182,186,66,174,169,98,231,123,215,
12,128,187,127,58,32,111,160,149,31,195,65,152,144,82,197,216,75,61,101,117,93,51,
60,0,67,211,241,206,90,87,56,240,73,177,43,155,157,71,191,136,103,116,140,205,143,
228,109,23,16,171,115,7,131,192,183,105,251,5,139,40,200,30,254,227,76,151,50,8,104,
118,233,25};
static const mi::math::Vector_struct<mi::Float32, 4> grad4[128] = {
    {0,1,1,1}, {0,-1,1,0}, {1,1,0,-1}, {0,-1,1,-1}, {0,1,1,0},
    {1,0,-1,1}, {0,-1,-1,0}, {-1,0,-1,-1}, {0,1,-1,1}, {1,1,0,1},
    {1,0,-1,-1}, {0,1,1,-1}, {0,1,-1,0}, {-1,1,0,1}, {0,-1,-1,1},
    {-1,0,1,-1}, {0,-1,-1,-1}, {1,0,1,1}, {-1,-1,0,-1}, {0,-1,1,1},
    {-1,1,0,-1}, {0,1,-1,-1}, {1,-1,0,1}, {0,-1,-1,0}, {-1,0,-1,1},
    {1,-1,0,-1}, {0,-1,1,0}, {-1,-1,0,1}, {0,1,-1,0}, {1,1,0,-1},
    {-1,0,1,1}, {0,1,1,0}, {1,1,0,-1}, {0,1,1,-1}, {-1,0,1,1},
    {0,1,1,0}, {0,-1,1,-1}, {0,-1,-1,0}, {1,0,-1,1}, {0,1,-1,1},
    {-1,0,-1,-1}, {1,0,-1,-1}, {1,1,0,1}, {0,1,-1,0}, {0,1,1,1},
    {0,-1,1,0}, {-1,1,0,1}, {0,1,-1,0}, {1,1,0,-1}, {0,-1,-1,1},
    {-1,0,1,-1}, {0,-1,-1,-1}, {1,0,1,1}, {-1,-1,0,-1}, {0,-1,1,1},
    {-1,1,0,-1}, {0,1,-1,-1}, {1,-1,0,1}, {0,-1,-1,0}, {-1,0,-1,1},
    {1,-1,0,-1}, {0,1,1,0}, {0,-1,1,0}, {-1,-1,0,1}, {1,0,1,1},
    {-1,-1,0,-1}, {0,1,1,0}, {-1,0,1,-1}, {1,1,0,1}, {-1,0,-1,-1},
    {0,-1,-1,0}, {1,0,-1,-1}, {-1,0,-1,1}, {1,-1,0,-1}, {0,1,1,-1},
    {0,1,-1,0}, {-1,1,0,1}, {0,-1,-1,1}, {1,1,0,-1}, {-1,0,1,1},
    {0,-1,-1,-1}, {1,0,-1,1}, {0,1,1,1}, {0,-1,1,0}, {-1,1,0,-1},
    {0,-1,1,1}, {0,1,-1,-1}, {1,-1,0,1}, {0,-1,1,0}, {-1,-1,0,1},
    {0,1,-1,0}, {0,-1,1,-1}, {0,1,1,0}, {1,1,0,-1}, {0,-1,-1,0},
    {0,1,-1,1}, {0,1,-1,1}, {1,1,0,1}, {1,0,-1,-1}, {0,1,-1,0},
    {0,1,1,1}, {0,-1,1,0}, {-1,1,0,1}, {0,1,-1,0}, {1,1,0,-1},
    {0,-1,-1,1}, {-1,0,1,-1}, {0,-1,-1,-1}, {1,0,1,1}, {-1,-1,0,-1},
    {0,-1,1,1}, {-1,1,0,-1}, {0,1,-1,-1}, {1,-1,0,1}, {0,-1,-1,0},
    {-1,0,-1,1}, {1,-1,0,-1}, {0,1,1,0}, {0,-1,1,0}, {-1,-1,0,1},
    {1,1,0,-1}, {0,1,1,-1}, {-1,0,1,1}, {0,1,1,0}, {0,-1,1,-1},
    {1,0,-1,1}, {0,-1,-1,0}, {-1,0,-1,-1}
};
/// access to grad4
inline mi::Float32 grad128(const mi::Uint32 hash,
                           const mi::Float32 x, const mi::Float32 y, const mi::Float32 z, const mi::Float32 w)
{
    return x*grad4[hash].x + y*grad4[hash].y + z*grad4[hash].z + w*grad4[hash].w;
}
/// perlin noise: ridge
inline mi::Float32 ridge(mi::Float32 h, const mi::Float32 offset){ h = offset - fabsf(h); return h*h; }

//----------------------------------------------------------------------
/// basic Perlin noise
///
/// \param[in] pos a position in the homogeneous coordinates
/// \return noise value
inline mi::Float32 perlin_noise(mi::math::Vector<mi::Float32, 4> pos)
{
    const mi::Uint32 X = __float2int_rd(pos.x),
		       Y = __float2int_rd(pos.y),
		       Z = __float2int_rd(pos.z),
		       W = __float2int_rd(pos.w);
    pos.x -= floorf(pos.x);
    pos.y -= floorf(pos.y);
    pos.z -= floorf(pos.z);
    pos.w -= floorf(pos.w);
    const mi::Float32 u = fade(pos.x),
	        v = fade(pos.y),
		w = fade(pos.z),
		x = fade(pos.w);
    const mi::Uint32 AX = rnd1[ X   &255] & 127,
		       BX = rnd1[(X+1)&255] & 127,
		       AY = rnd2[ Y   &255] & 127,
		       BY = rnd2[(Y+1)&255] & 127,
		       AZ = rnd3[ Z   &255] & 127,
		       BZ = rnd3[(Z+1)&255] & 127;
          mi::Uint32 AW = rnd4[ W   &255] & 127;

    mi::Float32 result[2];
    for(mi::Uint32 i = 0; i < 2; ++i)
    {
	result[i] = lerp(lerp(lerp(grad128(AX^AY^AZ^AW, pos.x     , pos.y     , pos.z     , pos.w),
			           grad128(BX^AY^AZ^AW, pos.x-1.0f, pos.y     , pos.z     , pos.w),
			           u),
			      lerp(grad128(AX^BY^AZ^AW, pos.x     , pos.y-1.0f, pos.z     , pos.w),
				   grad128(BX^BY^AZ^AW, pos.x-1.0f, pos.y-1.0f, pos.z     , pos.w),
				   u),
			      v),
			 lerp(lerp(grad128(AX^AY^BZ^AW, pos.x     , pos.y     , pos.z-1.0f, pos.w),
			           grad128(BX^AY^BZ^AW, pos.x-1.0f, pos.y     , pos.z-1.0f, pos.w),
			           u),
			      lerp(grad128(AX^BY^BZ^AW, pos.x     , pos.y-1.0f, pos.z-1.0f, pos.w),
				   grad128(BX^BY^BZ^AW, pos.x-1.0f, pos.y-1.0f, pos.z-1.0f, pos.w),
				   u),
			      v),
			 w);
	AW = rnd4[(W+1)&255] & 127;
	pos.w -= 1.0f;
    }

    return lerp(result[0], result[1], x);
}

//----------------------------------------------------------------------
/// summed up frequency Perlin noise.
///
/// The parameter names are based on the paper, 
///
///    Ken Perlin, An Image Synthesizer, SIGGRAPH Volume 19, No. 3, 1985
///
/// Here is a simple explanation only, for details, please refer the
/// original paper
///
/// \param[in] pos  a 3D position to be evaluated
/// \param[in] time time variant, if not depends on time, set 0.0f.
/// \param[in] terms how many terms will be used. Recommended 1 to 5,
///            large number has heavier computation.
/// \param[in] turbulence_weight turbulence flow weight. Useful for
///            Marble solid texture. try (0,0,0,0) or (1,1,1,1).
/// \param[in] abs_noise take absolute value of the noise. try 0 first.
/// \param[in] ridged add ridged effect. try 1 when you want to see
///            some discontinuity
/// \return noise value
inline mi::Float32 summed_perlin_noise(const mi::math::Vector<mi::Float32, 3> &pos,
                                       const mi::Float32 time, 
                                       mi::Uint32 terms,
                                       const mi::math::Vector<mi::Float32, 4> &turbulence_weight,
                                       const bool abs_noise,
                                       const bool ridged)
{
    mi::Float32 sum = 0.0f;
    mi::Float32 weight = ridged ? 0.625f : 1.0f;
    mi::Float32 prev = 1.0f;
    mi::math::Vector<mi::Float32, 4> p(pos.x,pos.y,pos.z,time);
    while(terms-- != 0) {
        const mi::Float32 n = perlin_noise(p);
	const mi::Float32 n2 = ridged ? ridge(n, 1.0f) : (abs_noise ? fabsf(n) : n);
        sum += weight*prev*n2;
        p   += p;
	if(ridged)
	    prev = n2;
        weight *= 0.5f;
    }

    return ((turbulence_weight.x != 0.0f) || (turbulence_weight.y != 0.0f) ||
            (turbulence_weight.z != 0.0f) || (turbulence_weight.w != 0.0f))
        ? sinf(pos.x*turbulence_weight.x + pos.y*turbulence_weight.y +
               pos.z*turbulence_weight.z + time*turbulence_weight.w + sum)
        : sum;
}


//----------------------------------------------------------------------
}} // namespace nv::index_common
#endif // NVIDIA_INDEX_BIN_COMMON_PERLIN_NOISE_UTILITY_H
