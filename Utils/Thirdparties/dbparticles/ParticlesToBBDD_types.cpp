/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ParticlesToBBDD_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace BBDDParticles {


Particle::~Particle() throw() {
}


void Particle::__set_time(const double val) {
  this->time = val;
}

void Particle::__set_partId(const int32_t val) {
  this->partId = val;
}

void Particle::__set_x(const double val) {
  this->x = val;
}

void Particle::__set_y(const double val) {
  this->y = val;
}

void Particle::__set_z(const double val) {
  this->z = val;
}

void Particle::__set_doubleProperties(const std::map<std::string, double> & val) {
  this->doubleProperties = val;
}

void Particle::__set_intProperties(const std::map<std::string, int32_t> & val) {
  this->intProperties = val;
}

const char* Particle::ascii_fingerprint = "C029FD862DC112401DAF504F8CF488E0";
const uint8_t Particle::binary_fingerprint[16] = {0xC0,0x29,0xFD,0x86,0x2D,0xC1,0x12,0x40,0x1D,0xAF,0x50,0x4F,0x8C,0xF4,0x88,0xE0};

uint32_t Particle::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partId);
          this->__isset.partId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->z);
          this->__isset.z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->doubleProperties.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              std::string _key5;
              xfer += iprot->readString(_key5);
              double& _val6 = this->doubleProperties[_key5];
              xfer += iprot->readDouble(_val6);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.doubleProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->intProperties.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _ktype8;
            ::apache::thrift::protocol::TType _vtype9;
            xfer += iprot->readMapBegin(_ktype8, _vtype9, _size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              std::string _key12;
              xfer += iprot->readString(_key12);
              int32_t& _val13 = this->intProperties[_key12];
              xfer += iprot->readI32(_val13);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.intProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Particle::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Particle");

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->partId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("doubleProperties", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->doubleProperties.size()));
    std::map<std::string, double> ::const_iterator _iter14;
    for (_iter14 = this->doubleProperties.begin(); _iter14 != this->doubleProperties.end(); ++_iter14)
    {
      xfer += oprot->writeString(_iter14->first);
      xfer += oprot->writeDouble(_iter14->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intProperties", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->intProperties.size()));
    std::map<std::string, int32_t> ::const_iterator _iter15;
    for (_iter15 = this->intProperties.begin(); _iter15 != this->intProperties.end(); ++_iter15)
    {
      xfer += oprot->writeString(_iter15->first);
      xfer += oprot->writeI32(_iter15->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Particle &a, Particle &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.partId, b.partId);
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
  swap(a.doubleProperties, b.doubleProperties);
  swap(a.intProperties, b.intProperties);
  swap(a.__isset, b.__isset);
}

Particle::Particle(const Particle& other16) {
  time = other16.time;
  partId = other16.partId;
  x = other16.x;
  y = other16.y;
  z = other16.z;
  doubleProperties = other16.doubleProperties;
  intProperties = other16.intProperties;
  __isset = other16.__isset;
}
Particle& Particle::operator=(const Particle& other17) {
  time = other17.time;
  partId = other17.partId;
  x = other17.x;
  y = other17.y;
  z = other17.z;
  doubleProperties = other17.doubleProperties;
  intProperties = other17.intProperties;
  __isset = other17.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Particle& obj) {
  using apache::thrift::to_string;
  out << "Particle(";
  out << "time=" << to_string(obj.time);
  out << ", " << "partId=" << to_string(obj.partId);
  out << ", " << "x=" << to_string(obj.x);
  out << ", " << "y=" << to_string(obj.y);
  out << ", " << "z=" << to_string(obj.z);
  out << ", " << "doubleProperties=" << to_string(obj.doubleProperties);
  out << ", " << "intProperties=" << to_string(obj.intProperties);
  out << ")";
  return out;
}


InsertData::~InsertData() throw() {
}


void InsertData::__set_data(const std::vector<Particle> & val) {
  this->data = val;
}

void InsertData::__set_time(const int32_t val) {
  this->time = val;
}

const char* InsertData::ascii_fingerprint = "818AB2776FE035EBD499AA89B7256F96";
const uint8_t InsertData::binary_fingerprint[16] = {0x81,0x8A,0xB2,0x77,0x6F,0xE0,0x35,0xEB,0xD4,0x99,0xAA,0x89,0xB7,0x25,0x6F,0x96};

uint32_t InsertData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->data.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += this->data[_i22].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InsertData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("InsertData");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->data.size()));
    std::vector<Particle> ::const_iterator _iter23;
    for (_iter23 = this->data.begin(); _iter23 != this->data.end(); ++_iter23)
    {
      xfer += (*_iter23).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(InsertData &a, InsertData &b) {
  using ::std::swap;
  swap(a.data, b.data);
  swap(a.time, b.time);
  swap(a.__isset, b.__isset);
}

InsertData::InsertData(const InsertData& other24) {
  data = other24.data;
  time = other24.time;
  __isset = other24.__isset;
}
InsertData& InsertData::operator=(const InsertData& other25) {
  data = other25.data;
  time = other25.time;
  __isset = other25.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const InsertData& obj) {
  using apache::thrift::to_string;
  out << "InsertData(";
  out << "data=" << to_string(obj.data);
  out << ", " << "time=" << to_string(obj.time);
  out << ")";
  return out;
}


InsertResult::~InsertResult() throw() {
}


void InsertResult::__set_sucess(const bool val) {
  this->sucess = val;
}

void InsertResult::__set_error(const std::string& val) {
  this->error = val;
}

const char* InsertResult::ascii_fingerprint = "1767FFB0CB3D9275BC64B198AB3B8A8B";
const uint8_t InsertResult::binary_fingerprint[16] = {0x17,0x67,0xFF,0xB0,0xCB,0x3D,0x92,0x75,0xBC,0x64,0xB1,0x98,0xAB,0x3B,0x8A,0x8B};

uint32_t InsertResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sucess);
          this->__isset.sucess = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InsertResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("InsertResult");

  xfer += oprot->writeFieldBegin("sucess", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->sucess);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(InsertResult &a, InsertResult &b) {
  using ::std::swap;
  swap(a.sucess, b.sucess);
  swap(a.error, b.error);
  swap(a.__isset, b.__isset);
}

InsertResult::InsertResult(const InsertResult& other26) {
  sucess = other26.sucess;
  error = other26.error;
  __isset = other26.__isset;
}
InsertResult& InsertResult::operator=(const InsertResult& other27) {
  sucess = other27.sucess;
  error = other27.error;
  __isset = other27.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const InsertResult& obj) {
  using apache::thrift::to_string;
  out << "InsertResult(";
  out << "sucess=" << to_string(obj.sucess);
  out << ", " << "error=" << to_string(obj.error);
  out << ")";
  return out;
}

} // namespace
