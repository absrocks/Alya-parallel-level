!-----------------------------------------------------------------------
!> @addtogroup Parall
!> @{
!> @file    mod_par_tools.f90
!> @author  houzeaux
!> @date    2018-10-31
!> @brief   Parallel tools
!> @details Tools for doing sequential things in parallel ;o)
!-----------------------------------------------------------------------

module mod_par_tools

  use def_kintyp,         only : ip,rp,lg
  use mod_maths,          only : maths_heap_sort
  use mod_communications, only : PAR_ALLGATHER
  use mod_communications, only : PAR_ALLGATHERV
  use mod_communications, only : PAR_MAX
  use mod_parall,         only : PAR_CODE_SIZE
  use mod_memory,         only : memory_alloca
  use mod_memory,         only : memory_deallo
  use mod_memory,         only : memory_size
  use mod_maths,          only : maths_merge_ordered_lists
  use mod_std

  implicit none

  public :: par_tools_merge_lists    ! Merges lists generated in parallel
  public :: par_tools_gathered_graph ! gather sequential graphs at root
  
contains

  !-----------------------------------------------------------------------
  !>  
  !> @author  houzeaux
  !> @date    2018-10-30
  !> @brief   Merge parallel lists
  !> @details Marge lists in parallel, each one being generated by the slaves
  !> 
  !-----------------------------------------------------------------------

  subroutine par_tools_merge_lists(array,memor)

    use def_master
    integer(ip), pointer, intent(inout) :: array(:)
    integer(8),           intent(inout) :: memor(2)
    integer(ip), pointer                :: array_size_gat(:)
    integer(ip), pointer                :: array_gat(:)
    integer(ip)                         :: array_size
    integer(ip)                         :: ii,jj,kk,total_size
    integer(ip)                         :: minvalue

    minvalue   = 0
    array_size = memory_size(array)
    total_size = array_size
    
    call PAR_MAX(total_size)
    
    if( total_size > 0 ) then

       nullify(array_gat)

       allocate(array_size_gat(0:PAR_CODE_SIZE-1))   
       call PAR_ALLGATHER(array_size,array_size_gat)

       total_size = sum(array_size_gat)
       allocate(array_gat(total_size))
       call PAR_ALLGATHERV(array,array_gat,array_size_gat)

       call maths_heap_sort(2_ip,total_size,array_gat)
       
       jj = minvalue
       kk = 0
       do ii = 1,total_size
          if( array_gat(ii) <= jj ) then
             array_gat(ii) = minvalue
          else
             kk            = kk + 1
             array_gat(kk) = array_gat(ii)
             jj            = array_gat(ii)
          end if
       end do
       if( kk < total_size ) array_gat(kk+1:) = minvalue

       total_size = count(array_gat/=minvalue,KIND=ip)
       call memory_deallo(memor,'ARRAY','par_merge_parallel_list',array)
       call memory_alloca(memor,'ARRAY','par_merge_parallel_list',array,total_size)
       array(1:total_size) = array_gat(1:total_size)

       deallocate(array_size_gat)
       deallocate(array_gat)

    end if

  end subroutine par_tools_merge_lists

  !-----------------------------------------------------------------------
  !> 
  !> @author  houzeaux
  !> @date    2018-10-31
  !> @brief   Merge graphs
  !> @details Marge graphs generated in parallel into a sequential one
  !> 
  !-----------------------------------------------------------------------

  subroutine par_tools_gathered_graph(ja_type,lninv_gat,MEMORY_COUNTER)

    use def_kintyp
    use def_domain
    use def_master
    use mod_communications
    use mod_parall
    use mod_memory
    implicit none
    type(i1p),   pointer,  intent(inout) :: ja_type(:)
    integer(ip), pointer,  intent(inout) :: lninv_gat(:)
    integer(8),  optional, intent(inout) :: MEMORY_COUNTER(2)
    integer(ip), pointer                 :: inul1(:)
    integer(ip), pointer                 :: inul2(:,:)

    integer(ip), pointer                 :: nz_gat(:)
    integer(4),  pointer                 :: nn_gat(:)
    integer(ip), pointer                 :: ia_gat(:)
    integer(ip), pointer                 :: ja_gat(:)
    !integer(ip), pointer                 :: lninv_gat(:)

    integer(ip), pointer                 :: lninv_send(:)
    integer(ip), pointer                 :: ja_send(:)

    integer(ip)                          :: inul0(1)
    integer(ip)                          :: nn,nz,ii,izdom
    integer(ip)                          :: index_ipoin
    integer(ip)                          :: isize,ipoin,apoin,npoin_mesh
    integer(ip)                          :: ipart,nz_typ

    integer(8)                           :: memor(2)

    if( present(MEMORY_COUNTER) ) then
       memor = MEMORY_COUNTER
    else
       memor = par_memor
    end if

    if( ISEQUEN ) then

       call runend('PAR_TOOLS_GATHERED_GRAPH: IMPOSSIBLE IN SEQUENTIAL')

    else

       nullify(inul1)
       nullify(inul2)
       nullify(nz_gat)
       nullify(nn_gat)
       nullify(ia_gat) 
       nullify(ja_gat)
       nullify(lninv_gat)
       nullify(lninv_send)
       nullify(ja_send)
       nullify(ja_type)

       if( IMASTER ) then

          call memory_alloca(memor,'NZ_GAT','par_tools_gathered_graph',nz_gat,PAR_CODE_SIZE,lboun=0_ip)
          call memory_alloca(memor,'NZ_GAT','par_tools_gathered_graph',nn_gat,int(PAR_CODE_SIZE,4),lboun=0_4)
          nz              = 0_ip
          nn_gat(0)       = 0
          nn_gat(1:npart) = npoin_par(1:npart)

       else
          !
          ! Slaves mark boudnary node with negative sign
          !
          nz         = nzdom
          nn         = npoin
          npoin_mesh = npoin_own
          call memory_alloca(memor,'LNINV_SEND','par_tools_gathered_graph',lninv_send,npoin,'DO_NOT_INITIALIZE')
          call memory_alloca(memor,'JA_SEND'   ,'par_tools_gathered_graph',ja_send,   nzdom,'DO_NOT_INITIALIZE')
          do ipoin = 1,npoi1
             lninv_send(ipoin)       =  lninv_loc(ipoin)
          end do
          !lninv_send(1:npoi1)       =  lninv_loc(1:npoi1)
          !lninv_send(npoi1+1:npoin) = -lninv_loc(npoi1+1:npoin)
          do ipoin = npoi1+1,npoin             
             lninv_send(ipoin) = -lninv_loc(ipoin)
          end do
          do izdom = 1,nzdom
             ja_send(izdom)          =  lninv_loc(c_dom(izdom))
          end do
          !ja_send(1:nzdom)          =  lninv_loc(c_dom(1:nzdom))
          do ipoin = 1,npoin
             isize = r_dom(ipoin+1)-r_dom(ipoin)
             call maths_heap_sort(2_ip,isize,ja_send(r_dom(ipoin):r_dom(ipoin+1)-1))
          end do

       end if
       !
       ! NPOIN_MESH: number of nodes (excluding duplicated ndoes)
       ! Gather graph sizes NZ_GAT and global numbering LNINV_GAT
       !
       call PAR_SUM(npoin_mesh)
       call PAR_GATHER(nz,nz_gat)

       if( IMASTER ) then
          call memory_alloca(memor,'JA_TYPE'  ,'par_tools_gathered_graph',ja_type  ,npoin_mesh)
          call memory_alloca(memor,'LNINV_GAT','par_tools_gathered_graph',lninv_gat,npoin_total,'DO_NOT_INITIALIZE')
       end if
       call PAR_GATHERV(lninv_send,lninv_gat,nn_gat)
       !
       ! Merge graphs into type JA_TYPE
       !
       if( IMASTER ) then
          index_ipoin = 0
          do ipart = 1,PAR_CODE_SIZE-1

             !call memory_alloca(memor,'LNINV_GAT','par_tools_gathered_graph',lninv_gat,npoin_par(ipart)     ,'DO_NOT_INITIALIZE')
             call memory_alloca(memor,'IA_GAT'   ,'par_tools_gathered_graph',ia_gat   ,npoin_par(ipart)+1_ip,'DO_NOT_INITIALIZE')
             call memory_alloca(memor,'JA_GAT'   ,'par_tools_gathered_graph',ja_gat   ,nz_gat(ipart)        ,'DO_NOT_INITIALIZE')

             call PAR_SEND_RECEIVE(inul1,ia_gat   ,'IN MY CODE',ipart,'SYNCHRONOUS')
             call PAR_SEND_RECEIVE(inul1,ja_gat   ,'IN MY CODE',ipart,'SYNCHRONOUS')

             do ii = 1,npoin_par(ipart)
                nz    = ia_gat(ii+1) - ia_gat(ii)
                ipoin = lninv_gat(ii+index_ipoin)
                apoin = abs(ipoin)
                if( ipoin > 0 ) then
                   !
                   ! Interior node: graph is necessarily complete
                   !
                   call memory_alloca(memor,'JA_TYPE','par_tools_gathered_graph',ja_type(ipoin) % l,nz)
                   ja_type(ipoin) % l(1:nz) = ja_gat(ia_gat(ii):ia_gat(ii+1)-1)
                else
                   !
                   ! Boundary node: merge list
                   !
                   if( associated(ja_type(apoin) % l) ) then
                      call maths_merge_ordered_lists(nz,ja_gat(ia_gat(ii):),nz_typ,ja_type(apoin) % l,MEMORY_COUNTER=memor)                    
                   else
                      nz_typ = int(1.5_rp*real(nz,rp))
                      call memory_alloca(memor,'JA_TYPE','par_tools_gathered_graph',ja_type(apoin) % l,nz_typ)
                      ja_type(apoin) % l(1:nz) = ja_gat(ia_gat(ii):ia_gat(ii+1)-1)
                   end if
                end if
                lninv_gat(ii+index_ipoin) = apoin
             end do
             index_ipoin = index_ipoin + npoin_par(ipart)
             call memory_deallo(memor,'JA_GAT'   ,'par_tools_gathered_graph',ja_gat)
             call memory_deallo(memor,'IA_GAT'   ,'par_tools_gathered_graph',ia_gat)
             !call memory_deallo(memor,'LNINV_GAT','par_tools_gathered_graph',lninv_gat)             
          end do
          !
          ! Resize graph
          !
          do ipoin = 1,npoin_mesh
             nz = size(ja_type(ipoin) % l)
             if( ja_type(ipoin) % l(nz) == 0 ) then
                do while( ja_type(ipoin) % l(nz) == 0 )
                   nz = nz - 1
                end do
                call memory_resize(memor,'JA_OUT','maths_merge_ordered_lists',ja_type(ipoin) % l,nz)
             end if
             !print*,ipoin,': ',ja_type(ipoin) % l
          end do
          call memory_deallo(memor,'NZ_GAT','par_tools_gathered_graph',nz_gat)
          call memory_deallo(memor,'NN_GAT','par_tools_gathered_graph',nn_gat)

       else

          call PAR_SEND_RECEIVE(npoin+1_ip,0_ip,r_dom,inul0,'IN MY CODE',0_ip,'SYNCHRONOUS')
          if( nz > 0 ) call PAR_SEND_RECEIVE(nz,0_ip,ja_send,inul0,'IN MY CODE',0_ip,'SYNCHRONOUS')

          call memory_deallo(memor,'LNINV_SEND','par_tools_gathered_graph',lninv_send)          
          call memory_deallo(memor,'JA_SEND'   ,'par_tools_gathered_graph',ja_send)          

       end if

    end if

    if( present(MEMORY_COUNTER) ) then
       MEMORY_COUNTER = memor 
    else
       par_memor = memor
    end if

  end subroutine par_tools_gathered_graph

end module mod_par_tools
  !> @}
